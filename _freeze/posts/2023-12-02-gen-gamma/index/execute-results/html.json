{
  "hash": "38d6132bbc1a518f17ace87820f34d5e",
  "result": {
    "markdown": "---\ntitle: The Generalized Gamma Distribution For Parametric Survival\ndate: \"2023-12-02\"\ncode-fold: true\necho: true\nfig-cap-location: top\ncategories: []\nnumber-sections: false\ndraft: true\n---\n\n\nA couple weeks back, I posted a little something something on [the Shifted Beta Geometric distribution](https://dpananos.github.io/posts/2023-11-02-shifted-beta-geometric/).  That distribution is used in estimating churn in contractual settings (think Netflix, or any other service whereby you renew your service monthly).\n\nIts a nice model, but I want something more flexible.  I've been aware of the generalized gamma  distribution (GDD) through Jordan Nafa (who likely uses it for some very interesting decision theory applications).  The GGD is a three parameter extension of your typical gamma distribution that looks like\n\n$$ f(t) = \\dfrac{\\beta}{\\Gamma(k) \\cdot \\theta} \\left( \\dfrac{t}{\\theta} \\right)^{k\\cdot \\beta-1} \\exp\\left(-\\left[\\frac{t}{\\theta} \\right]^\\beta\\right) \\>.$$\n\nwhere $\\theta>0$ is a scale parameter, $\\beta>0$ and $k>0$ are shape parameters, and $\\Gamma(x)$ is the gamma function.  \n\nNote that the exponential, gamma, and weibull distributions are special cases (and the log normal is a limiting distribution) [^1].  \n\nThat is especially nice for me.  I'm working on some life time value modelling and it would be great if I didn't have to try several models.  Instead I can just use the generalized gamma and hope it fits well enough if the data are best approximated via one of the aforementioned survival functions.\n\nIn this post, I want to implement some survival analyses using the generalized gamma.  We'll steal some code from Krzysztof Sakrejda, and make some connections to the `{flexsurv}` implementation of the distribution as well.\n\nLet's get started.\n\n## Data\n\nWe'll need some data. Rather than simulate it myself, I'll use the `veteran` data from `{survival}`.  The survival function is roughly exponential, which is good because we know the generalized gamma can fit it in principle.  There is a `treatment` indicator in these data, so we'll fit one survival curve to each strata.  Shown below are the Kaplan Meir non-parametric estimates for these data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(cmdstanr)\nlibrary(survival)\n\nmy_blue <- rgb(45/250, 62/250, 80/250, 1)\n\nmy_theme<- theme_classic() %+replace% \n           theme(panel.grid.major = element_line(),\n                 aspect.ratio = 1/1.61)\n\nvet_km <- survfit(Surv(time, status) ~ strata(trt), data=veteran)\n\nbase_plot <- broom::tidy(vet_km) %>% \n              mutate(strata = str_remove(strata, 'strata\\\\(trt\\\\)=')) %>% \n              ggplot(aes(time, estimate, ymin=conf.low, ymax=conf.high, color=strata, fill=strata)) + \n              geom_step() + \n              pammtools::geom_stepribbon(alpha=0.5, size=0) \n\nbase_plot +\n  my_theme + \n  labs(x='Time', y=expression(S(t))) +\n  scale_fill_brewer(palette = 'Set1') +\n  scale_color_brewer(palette = 'Set1') +\n  xlim(0, 500)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n## `_lpdf`, `_lcdf`, and `_lccdf` Implementations in Stan\n\nWe're going to need three functions in Stan:\n\n* `generalized_gamma_lpdf` so we can increment the log posterior density when we observe an outcome.\n* `generalized_gamma_lccdf` so we can increment the log posterior density when we observe a censoring event, and \n* `generalized_gamma_lcdf` so we can implement the `_lccdf`.\n\n\nThe first and third functions are implemented already by Krzysztof Sakrejda in [this repo](https://github.com/sakrejda/tooling/blob/master/models/stan-lang/functions/generalized-gamma.stan.part).  Krzysztof uses a slightly different parameterization than what I've written here.  The density is\n\n$$ f(x) $$\n\nThe `_lpdf` and `_lcdf` are given, so now we just need the complementary cdf function `_lccdf`. Since Stan works on the log probability scale, we need to return the the log of the complementary cdf.  Since we have the log cdf we could just do\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.stan}\n\n\nreal lawless_generalized_gamma_lccdf(real x, real k, real mu, real sigma) {\n \n return log(1 - exp(lawless_generalized_gamma_lcdf(x | k, mu sigma)));\n \n}\n```\n:::\n:::\n\n\n\nStan has a nicer function to do this called `log_diff_exp` which can be used to take differences in exponential space and then take the log of the result.  Our `functions` block then looks like\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.stan}\nfunctions {\n  \nreal lawless_generalized_gamma_lpdf(real x, real k, real mu, real sigma) {\n  real w;\n  real d;\n  w = (log(x)-mu)/sigma;\n  d = (k-.5)*log(k) - log(sigma) - lgamma(k) +\n    (sqrt(k)*w - k*exp(1/sqrt(k)*w)) - y;\n  return d;\n}\n\nreal lawless_generalized_gamma_cdf(real x, real k, real mu, real sigma) {\n  real w;\n  real d;\n  w = (log(x) - mu)/sigma;\n  d = gamma_p(k, k*exp(w/sqrt(k)));\n  return d;\n}\n\nreal lawless_generalized_gamma_lccdf(real x, real k, real mu, real sigma) {\n \n return log_diff_exp(0, lawless_generalized_gamma_lcdf(x| k, mu, sigma));\n \n}\n\n}\n```\n:::\n:::\n\n\nThe `data` and `paramaters` block are not all that interesting, and if you've coded in Stan before you can probably guess what they look like (if not, everything is on github, so take a look there).\n\nThe `model` block is where the meat of the work is.  For each observation, we will increment `target` by `_lpdf` if the observation is observed, else we will increment by `_lccdf`. The `model` block looks like\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.stan}\nmodel {\n  mu ~ student_t(30, 0, 1);\n  sigma ~ student_t(30, 1, 0.05);\n  k ~ student_t(30, 1, 0.05);\n  \n  for(i in 1:n) {\n    if(censored[i] == 1) {\n      target += lawless_generalized_gamma_lccdf(time[i] | k, mu, sigma);\n    } else {\n      target += lawless_generalized_gamma_lpdf(time[i] | k, mu, sigma);\n    }\n  }\n}\n```\n:::\n:::\n\n\n[^1]: Left as an exercise to the reader.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}