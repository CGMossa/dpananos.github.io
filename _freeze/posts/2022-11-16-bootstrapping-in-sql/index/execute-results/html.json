{
  "hash": "13a2fd8540b44ce5d8914a42741e2620",
  "result": {
    "markdown": "---\ntitle: Bootstrapping in SQL\ndate: \"2022-11-16\"\ncode-fold: false\necho: false\nfig-cap-location: top\ncategories: [Statistics]\nnumber-sections: false\n---\n\n\n## Introduction\n\nRemember the [\"Double Down\"](https://en.wikipedia.org/wiki/Double_Down_(sandwich)) from KFC?  It was bacon and cheese sandwiched between two deep fried pieces of chicken. I'm willing to bet we all conceived of it independently (as in \"LOL wouldn't it be crazy if...\"), realistically could have made it ourselves, but were smart enough not to because \"sure we could but... why?\".  \n\nThis blog post is the Double Down of Statistics.\n\n## Bootstrapping in SQL.  No, Really.\n\nTwo things which have made my stats like easier:\n\n* Bootstrapping, and \n* Tidy data\n\nR's `rsample::bootstraps` seems to do one in terms of the other.  Take a look at the output of that function.  We have, in essence, one bootstrapped dataset per row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(rsample )\n\nrsample::bootstraps(cars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Bootstrap sampling \n# A tibble: 25 × 2\n   splits          id         \n   <list>          <chr>      \n 1 <split [50/18]> Bootstrap01\n 2 <split [50/16]> Bootstrap02\n 3 <split [50/16]> Bootstrap03\n 4 <split [50/18]> Bootstrap04\n 5 <split [50/21]> Bootstrap05\n 6 <split [50/19]> Bootstrap06\n 7 <split [50/20]> Bootstrap07\n 8 <split [50/18]> Bootstrap08\n 9 <split [50/20]> Bootstrap09\n10 <split [50/19]> Bootstrap10\n# … with 15 more rows\n```\n:::\n:::\n\n\nIn theory, I could unnest this and have one observation from each bootstrap per row, with `id` serving as an indicator to tell me to which resample the observation belongs to.  Which means...I could theoretically bootstrap in SQL.\n\nSo, let's do that.  I'm going to use duckdb because its SQL-like and has some stats functions (whereas SQLite does not).\n\n\nLet's sample some pairs $(x_i, y_i)$ from the relationship $y_i = 2x_i + 1 + \\varepsilon_i$, where the  $\\varepsilon$ are iid draws from a standard Gaussian  Let's stick that in a dataframe along with a row number column into our database.  The data are shown in @tbl-original-data.\n\n\n::: {.cell}\n\n:::\n\n::: {#tbl-original-data .cell tbl-cap='My Data'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:center;\"> original_rownum </th>\n   <th style=\"text-align:center;\"> x </th>\n   <th style=\"text-align:center;\"> y </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:center;\"> 1 </td>\n   <td style=\"text-align:center;\"> 2.09 </td>\n   <td style=\"text-align:center;\"> 5.73 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 2 </td>\n   <td style=\"text-align:center;\"> 0.97 </td>\n   <td style=\"text-align:center;\"> 3.58 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 3 </td>\n   <td style=\"text-align:center;\"> 0.70 </td>\n   <td style=\"text-align:center;\"> 1.37 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 4 </td>\n   <td style=\"text-align:center;\"> 1.44 </td>\n   <td style=\"text-align:center;\"> 4.84 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 5 </td>\n   <td style=\"text-align:center;\"> 2.07 </td>\n   <td style=\"text-align:center;\"> 4.14 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 6 </td>\n   <td style=\"text-align:center;\"> 1.67 </td>\n   <td style=\"text-align:center;\"> 3.09 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n\nTo bootstrap in SQL, we need to emulate what the unnested results of `rsample::bootstraps` would look like.  We need rows of (`strap_id`, `original_data_rownum`, and `bootstrap_rownum`).  Let's discuss the interpretation and purpose of each column.\n\n* `strap_id` plays the part of `id` in `rsample::bootstraps`. We're just going to group by this column and aggregate the resampled data later.\n\n* `original_data_rownum` doesn't really serve a purpose.  It contains integers 1 through $N$ (where $N$ is our original sample size).  We can do a cross join to get pairs (`strap_id`, `original_data_rownum`).  This means there will be $N$ copies of `strap_id`, meaning we can get $N$ resamples of our data for each `strap_id`.\n\n* `bootstrap_rownum` is a random integer between 1 and $N$.  This column DOES serve a purpose, its basically the sampling with replacement bit for the bootstrap.  Now, duckdb doesn't have a function to sample random integers.  To do this, I basically sample random numbers on the unit interval do some arithmetic to turn those into integers.  \n\nLet's set that up now.  The hardest part really is creating a sequence of numbers, but duckdb makes that pretty easy.\n\n### Query To Make `strap_id`\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n-- Set up strap_ids in a table\nCREATE OR REPLACE TABLE strap_ids(strap_id INTEGER);\n-- Do 1000 bootstraps\nINSERT INTO strap_ids(strap_id) select * from range(1, 1001, 1);\n\n```\n:::\n\n::: {.cell output.var='tbl1'}\n\n:::\n\n::: {#tbl-strap-ids .cell tbl-cap='Contents of `strap_ids`.  These play the role of `id` in the rsample output.'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:center;\"> strap_id </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:center;\"> 1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 2 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 3 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 4 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 5 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n### Query To Make `original_data_rownum`\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n-- Set up original_data_rownum in a table\nCREATE OR REPLACE TABLE original_data_rownum(original_rownum INTEGER);\n-- I have 2500 observations in my data\nINSERT INTO original_data_rownum(original_rownum) select * from range(1, 2500+1, 1);\n```\n:::\n\n::: {.cell output.var='tbl2'}\n\n:::\n\n::: {#tbl-original-data-rownum .cell tbl-cap='Contents of `original_data_rownum`.  These play the role of `id` in the rsample output.'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:center;\"> original_rownum </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:center;\"> 1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 2 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 3 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 4 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 5 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\nOk, now we have the two tables `strap_ids` and `original_data_rownum`.  All we need to do now is cross join then, and do the random number magic.  That's shown below in table @tbl-resample-template.\n\n### Query To Make `bootstrap_rownum`\n\n\n::: {.cell}\n\n```{.sql .cell-code}\ncreate or replace table resample_template as \nselect\n  strap_ids.strap_id,\n  original_data_rownum.original_rownum,\n  -- I have 2500 observations in my data\n  round( -0.5 + 2501*random()) as bootstrap_rownum,\nfrom\n  strap_ids\ncross join \n  original_data_rownum;\n```\n:::\n\n::: {.cell output.var='tbl3'}\n\n:::\n\n::: {#tbl-resample-template .cell tbl-cap='A sample from the table `resampel_template`.'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:center;\"> strap_id </th>\n   <th style=\"text-align:center;\"> original_rownum </th>\n   <th style=\"text-align:center;\"> bootstrap_rownum </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:center;\"> 573 </td>\n   <td style=\"text-align:center;\"> 2216 </td>\n   <td style=\"text-align:center;\"> 4 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 312 </td>\n   <td style=\"text-align:center;\"> 2227 </td>\n   <td style=\"text-align:center;\"> 1792 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 2 </td>\n   <td style=\"text-align:center;\"> 554 </td>\n   <td style=\"text-align:center;\"> 1577 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 440 </td>\n   <td style=\"text-align:center;\"> 381 </td>\n   <td style=\"text-align:center;\"> 688 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:center;\"> 969 </td>\n   <td style=\"text-align:center;\"> 1352 </td>\n   <td style=\"text-align:center;\"> 1840 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Actually Doing The Bootstrapping:  Its Just A Left Join!\n\nNow all we have to do is join the original data onto `resample_template`.  The join is going to happen `on original_data.original_rownum = resample_template.bootstrap_rownum`.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\ncreate or replace table resampled_data as\nselect\n  resample_template.strap_id,\n  resample_template.bootstrap_rownum,\n  original_data.x,\n  original_data.y\nfrom \n  resample_template\nleft join \n  original_data on original_data.original_rownum = resample_template.bootstrap_rownum;\n```\n:::\n\n\nAnd congratulations, you have what is in essence an unnested `rsample::bootstraps` output.  This happens shockingly fast in duckdb (actually, a bit faster than `rsample` does it, but that is anecdote I didn't actually time them).  The hard part now is the aggregation function.  Obviously, you can't do very complex statsitical aggregations in duckdb (or any other SQL dialect), but there are a few you can do.  For example, let's bootstrap the mean of $x$ and $y$, as well as the estimated regression coefficient.\n\n\n::: {.cell output.var='bsr'}\n\n```{.sql .cell-code}\nselect\n  'Bootstrap' || lpad(strap_id,4,0) as id,\n  'SQL' as method,\n  avg(x) as mean_x,\n  avg(y) as mean_y,\n  corr(y, x) * stddev(y) / stddev(x) as beta\nfrom resampled_data\ngroup by 1\norder by 1;\n```\n:::\n\n\nWe can easily compare the distributions obtained via the SQL bootstrap with distributions obtained from `rsample::bootstrap`\n\n\n::: {.cell}\n\n:::\n\n\n## But Does It Work\n\nYes...I think.  The averages for $x$ and $y$ look really good, but the SQL bootstrap tails for the regression coefficient are a little thin.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=960}\n:::\n:::\n\n\n## Conclusion\n\nThis is pretty silly, and probably inefficient.  I'm no data engineer, I'm just a guy with a Ph.D in stats and a lot of time on the weekend.  I should get a hobby or something.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}